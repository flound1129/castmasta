# Announce (TTS) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `announce(identifier, text, voice)` to `CastAgent` that synthesises speech with Piper TTS and streams the WAV to any connected AirPlay or Google Cast device.

**Architecture:** Run `piper` as a subprocess via `asyncio.create_subprocess_exec` (same pattern as `display_image` + ffmpeg), write output to a secure temp WAV file, call `backend.stream_file()` which already handles both AirPlay (pyatv) and Cast (FileServer + pychromecast). Clean up in `finally`.

**Tech Stack:** Python 3.11+, piper-tts>=1.2, asyncio, pytest-asyncio, click, fastmcp

---

### Task 1: Add `announce` to `CastAgent` (with tests)

**Files:**
- Modify: `castmasta/agent.py`
- Modify: `tests/test_agent.py`

**Step 1: Write failing tests**

Add to `tests/test_agent.py`:

```python
import os

@pytest.mark.asyncio
async def test_announce_streams_wav(agent, mock_airplay_backend, tmp_path):
    """announce() runs piper and calls stream_file with a .wav path."""
    agent.devices["dev1"] = mock_airplay_backend

    mock_proc = MagicMock()
    mock_proc.returncode = 0
    mock_proc.communicate = AsyncMock(return_value=(None, b""))

    with patch("castmasta.agent.asyncio.create_subprocess_exec", return_value=mock_proc) as mock_exec:
        await agent.announce("dev1", "Hello world")

    mock_exec.assert_called_once()
    call_args = mock_exec.call_args[0]
    assert call_args[0] == "piper"
    assert "--output_file" in call_args
    output_path = call_args[call_args.index("--output_file") + 1]
    assert output_path.endswith(".wav")

    mock_airplay_backend.stream_file.assert_called_once()
    streamed_path = mock_airplay_backend.stream_file.call_args[0][0]
    assert streamed_path.endswith(".wav")


@pytest.mark.asyncio
async def test_announce_cleans_up_temp_file_on_success(agent, mock_airplay_backend):
    """Temp WAV file is deleted after streaming."""
    agent.devices["dev1"] = mock_airplay_backend

    captured_path = []

    mock_proc = MagicMock()
    mock_proc.returncode = 0
    mock_proc.communicate = AsyncMock(return_value=(None, b""))

    original_exec = asyncio.create_subprocess_exec

    async def fake_exec(*args, **kwargs):
        # Write a real temp file so unlink can succeed
        output_path = args[args.index("--output_file") + 1]
        captured_path.append(output_path)
        Path(output_path).write_bytes(b"fake wav")
        return mock_proc

    with patch("castmasta.agent.asyncio.create_subprocess_exec", side_effect=fake_exec):
        await agent.announce("dev1", "Hello")

    assert captured_path, "No temp file path captured"
    assert not Path(captured_path[0]).exists(), "Temp file was not cleaned up"


@pytest.mark.asyncio
async def test_announce_raises_on_empty_text(agent, mock_airplay_backend):
    agent.devices["dev1"] = mock_airplay_backend
    with pytest.raises(ValueError, match="non-empty"):
        await agent.announce("dev1", "")


@pytest.mark.asyncio
async def test_announce_raises_on_invalid_voice(agent, mock_airplay_backend):
    agent.devices["dev1"] = mock_airplay_backend
    with pytest.raises(ValueError, match="voice"):
        await agent.announce("dev1", "Hello", voice="../evil/path")


@pytest.mark.asyncio
async def test_announce_raises_on_piper_failure(agent, mock_airplay_backend):
    agent.devices["dev1"] = mock_airplay_backend

    mock_proc = MagicMock()
    mock_proc.returncode = 1
    mock_proc.communicate = AsyncMock(return_value=(None, b"model not found"))

    with patch("castmasta.agent.asyncio.create_subprocess_exec", return_value=mock_proc):
        with pytest.raises(RuntimeError, match="piper"):
            await agent.announce("dev1", "Hello")


@pytest.mark.asyncio
async def test_announce_cleans_up_on_failure(agent, mock_airplay_backend):
    """Temp WAV file is deleted even if piper fails."""
    agent.devices["dev1"] = mock_airplay_backend

    captured_path = []

    async def fake_exec(*args, **kwargs):
        output_path = args[args.index("--output_file") + 1]
        captured_path.append(output_path)
        Path(output_path).write_bytes(b"partial")
        mock_proc = MagicMock()
        mock_proc.returncode = 1
        mock_proc.communicate = AsyncMock(return_value=(None, b"error"))
        return mock_proc

    with patch("castmasta.agent.asyncio.create_subprocess_exec", side_effect=fake_exec):
        with pytest.raises(RuntimeError):
            await agent.announce("dev1", "Hello")

    if captured_path:
        assert not Path(captured_path[0]).exists(), "Temp file not cleaned up on failure"
```

Also add `from pathlib import Path` to test imports if not already present.

**Step 2: Run tests to confirm they fail**

```bash
.venv/bin/pytest tests/test_agent.py -k "announce" -v 2>&1 | tail -20
```

Expected: FAILED (AttributeError: CastAgent has no attribute 'announce')

**Step 3: Implement `announce` in `castmasta/agent.py`**

Add these constants near the top of the file (after `MAX_DISPLAY_DURATION`):

```python
PIPER_VOICE_DATA_DIR = Path.home() / ".local/share/piper-voices"
DEFAULT_VOICE = "en_US-lessac-medium"
MAX_ANNOUNCE_TEXT_LEN = 4000
```

Add the method to `CastAgent` (after `display_image`):

```python
async def announce(
    self, identifier: str, text: str, voice: str = DEFAULT_VOICE,
) -> None:
    if not isinstance(text, str) or not text.strip():
        raise ValueError("text must be a non-empty string.")
    if len(text) > MAX_ANNOUNCE_TEXT_LEN:
        raise ValueError(f"text too long (max {MAX_ANNOUNCE_TEXT_LEN} chars).")
    if not voice or "/" in voice or "\\" in voice or ".." in voice:
        raise ValueError("voice must be a simple model name with no path separators.")

    backend = self._get_backend(identifier)

    fd, tmp_path = tempfile.mkstemp(suffix=".wav")
    os.close(fd)
    os.chmod(tmp_path, 0o600)
    try:
        proc = await asyncio.create_subprocess_exec(
            "piper",
            "--model", voice,
            "--data-dir", str(PIPER_VOICE_DATA_DIR),
            "--output_file", tmp_path,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.DEVNULL,
            stderr=asyncio.subprocess.PIPE,
        )
        _, stderr = await proc.communicate(input=text.encode())
        if proc.returncode != 0:
            raise RuntimeError(
                f"piper failed (exit {proc.returncode}): {stderr.decode(errors='replace')}"
            )
        await backend.stream_file(tmp_path)
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
```

**Step 4: Run tests to confirm they pass**

```bash
cd /home/adam/airplay-agent && .venv/bin/pytest tests/test_agent.py -k "announce" -v 2>&1 | tail -20
```

Expected: 6 tests PASSED

**Step 5: Run full test suite to confirm no regressions**

```bash
cd /home/adam/airplay-agent && .venv/bin/pytest tests/ -v 2>&1 | tail -10
```

Expected: all tests PASSED

**Step 6: Commit**

```bash
cd /home/adam/airplay-agent && bash scripts/git.sh commit "feat: add announce TTS method to CastAgent"
```

---

### Task 2: Add `announce` tool definition to `tools.py`

**Files:**
- Modify: `castmasta/tools.py`

**Step 1: Add the tool entry**

In `castmasta/tools.py`, add this entry to the `TOOLS` list (after the `display_image` entry, around line 160):

```python
{
    "name": "announce",
    "description": "Synthesise text to speech using Piper TTS and play it on a device",
    "parameters": {
        "type": "object",
        "properties": {
            "identifier": {"type": "string", "description": "Device identifier"},
            "text": {
                "type": "string",
                "description": "Text to speak (max 4000 characters)",
            },
            "voice": {
                "type": "string",
                "description": "Piper voice model name (default: en_US-lessac-medium)",
                "default": "en_US-lessac-medium",
            },
        },
        "required": ["identifier", "text"],
    },
},
```

**Step 2: Verify the tool appears in the list**

```bash
cd /home/adam/airplay-agent && .venv/bin/python -c "
from castmasta.tools import get_tool_names
names = get_tool_names()
assert 'announce' in names, f'announce not found: {names}'
print('OK - announce in tools:', names)
"
```

Expected: prints `OK - announce in tools: [...]`

**Step 3: Commit**

```bash
cd /home/adam/airplay-agent && bash scripts/git.sh commit "feat: add announce tool definition"
```

---

### Task 3: Add `announce` MCP tool to `mcp_server.py`

**Files:**
- Modify: `castmasta/mcp_server.py`

**Step 1: Add the MCP tool**

Add this after the `display_image` MCP tool (around line 229):

```python
@mcp.tool()
async def announce(identifier: str, text: str, voice: str = "en_US-lessac-medium") -> str:
    """Synthesise text to speech and play it on a device.

    Uses Piper TTS to convert text to a WAV file and streams it to the device.
    Voice models must be pre-installed in ~/.local/share/piper-voices/.

    Args:
        identifier: The device identifier
        text: Text to speak (max 4000 characters)
        voice: Piper voice model name (default: en_US-lessac-medium)
    """
    try:
        await agent.announce(identifier, text, voice)
        return f"Announced on {identifier}: {text[:60]}{'...' if len(text) > 60 else ''}"
    except (ValueError, FileNotFoundError) as e:
        return f"Invalid input: {e}"
    except RuntimeError as e:
        return f"Piper TTS error: {e}"
    except Exception:
        logger.exception("Failed to announce")
        return f"Failed to announce on {identifier}"
```

**Step 2: Verify syntax**

```bash
cd /home/adam/airplay-agent && .venv/bin/python -c "import castmasta.mcp_server; print('OK')"
```

Expected: `OK`

**Step 3: Commit**

```bash
cd /home/adam/airplay-agent && bash scripts/git.sh commit "feat: add announce MCP tool"
```

---

### Task 4: Add `announce` CLI command to `cli.py`

**Files:**
- Modify: `castmasta/cli.py`

**Step 1: Add the CLI command**

Add this after the `display_image` command (around line 244):

```python
@cli.command()
@click.argument("identifier")
@click.argument("text")
@click.option(
    "--voice", "-v", default="en_US-lessac-medium",
    help="Piper voice model name (default: en_US-lessac-medium)",
)
@click.pass_context
def announce(ctx, identifier, text, voice):
    """Synthesise text to speech and play it on a device."""
    agent: CastAgent = ctx.obj["agent"]
    asyncio.run(agent.announce(identifier, text, voice))
    click.echo(f"Announced: {text}")
```

**Step 2: Verify CLI shows announce command**

```bash
cd /home/adam/airplay-agent && .venv/bin/castmasta --help 2>&1 | grep announce
```

Expected: `  announce  Synthesise text to speech and play it on a device.`

**Step 3: Commit**

```bash
cd /home/adam/airplay-agent && bash scripts/git.sh commit "feat: add announce CLI command"
```

---

### Task 5: Add `piper-tts` dependency to `pyproject.toml`

**Files:**
- Modify: `pyproject.toml`

**Step 1: Add dependency**

In `pyproject.toml`, find the `dependencies = [` list and add `"piper-tts>=1.2",` as a new entry.

**Step 2: Install the dependency**

```bash
cd /home/adam/airplay-agent && .venv/bin/pip install -e ".[dev]" 2>&1 | tail -5
```

Expected: Successfully installed (or already satisfied)

**Step 3: Verify piper is importable**

```bash
cd /home/adam/airplay-agent && .venv/bin/python -c "import piper; print('piper OK')"
```

Expected: `piper OK`

**Step 4: Run full tests one final time**

```bash
cd /home/adam/airplay-agent && .venv/bin/pytest tests/ -v 2>&1 | tail -15
```

Expected: all tests PASSED

**Step 5: Commit + push**

```bash
cd /home/adam/airplay-agent && bash scripts/git.sh commit "chore: add piper-tts dependency" && bash scripts/git.sh push
```

